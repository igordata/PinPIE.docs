[title[=Статический контент]]
[sidemenu[ru/manual/sidemenu]]
[menu static[=
<ul>
  <li><a href="/ru/manual/static#static-tags">Статик теги</a></li>
  <li><a href="/ru/manual/static#time-hash">Хэш времени</a></li>
  <li><a href="/ru/manual/static#servers-sharding">Шардинг серверов</a></li>
  <li><a href="/ru/manual/static#custom-static-files-types">Кастомные типы</a></li>
  <li><a href="/ru/manual/static#compression">Сжатие</a></li>
  <li><a href="/ru/manual/static#minification">Минификация</a></li>
  <li><a href="/ru/manual/static#dimensions">Размеры</a></li>
  <li><a href="/ru/manual/static#i-don't-want-this">Мне это не нужно</a></li>
  <li><a href="/ru/manual/static#templates">Темплейты</a></li>
</ul>
]]
<article>
  <header><h1>Статический контент</h1></header>
  <p>
    Статические файлы это те, которые можно отослать человеку в браузер прямо с харда сервера безо всякой обработки.
    Обычно это картинки, клиентские javascript файлы, файлы css и прочие им подобные.
  </p>

  <section>
    <header>
      <h1>
        <a name="static-tags" href="#static-tags">#</a>
        Статик теги
      </h1>
    </header>
    <p>
      Статик теги призваны обеспечить автоматическое использование таких фишек статических файлов как минификация,
      сжатие gzip, и поддержка серверного шардинга.
    </p>
    <?= pcx('[[%тип=путь к файлу]]', 'html') ?>
    <p>
      Статик теги начинаются с символа <b>%</b> и типа статик контента,
      который берётся <b>не</b> из его расширения, а именно из самого тега;
      и пути к файлу. PinPIE поддерживает три типа статик тегов и отрисовывает их соответствующим образом.
    </p>

    <h2>Обычное использование</h2>
    <?= pcx('[[%js=/javascript/jquery.js]]
[[%css=/css/main.css]]
[[%img=/images/avatar.png]]', 'html') ?>
    <p>Эти теги будут заменены вот такими строками HTML-кода:</p>
    <?= pcx(h('<script type="text/javascript" src="//pinpie.ru/javascript/jquery.min.js?time=956603fa2e94d0321f5cf24a77702331"></script>
<link rel="stylesheet" type="text/css" href="//pinpie.ru/css/css.min.css?time=4ad3a55cc4b8e5ad0801d84959cde6b3">
<img src="//pinpie.ru/images/avatar.png?time=b17c93f172020c8c4c0f324b048b3434" width="64" height="64">'), 'html') ?>
    <h2>Только путь</h2>
    <p>Если вам нужен не весь HTML-тег, а только путь, то просто поставьте восклицательный знак:</p>
    <p>Синтаксис:</p>
    <?= pcx('[[!%js=/javascript/jquery.js]]
[[!%css=/css/main.css]]
[[!%img=/images/avatar.png]]', 'html') ?>
    <p>и получится только путь:</p>
    <?= pcx('//pinpie.ru/javascript/jquery.min.js?time=956603fa2e94d0321f5cf24a77702331
//pinpie.ru/css/css.min.css?time=4ad3a55cc4b8e5ad0801d84959cde6b3
//pinpie.ru/images/avatar.png?time=b17c93f172020c8c4c0f324b048b3434', 'html') ?>

    <p>То есть, да, вы можете использовать статик теги вот так:</p>
    <?= pcx(h('<img class="avatar small" src="[[!%img=/images/avatar.png]]" title="nickname (online)">'), 'html') ?>
    <h2>И с темплейтами</h2>

    <p>Синтаксис:</p>
    <?= pcx('[[!%img=/images/avatar.png]<b>template</b>]', 'html') ?>
    <p>Предположим, темплейт имеет такой код:</p>
    <?= pcx(h('<img class="avatar small" src="[[*content]]">'), 'html') ?>
    <p>и получается вот такой HTML:</p>
    <?= pcx(h('<img class="avatar small" src="//pinpie.ru/images/avatar.png?time=b17c93f172020c8c4c0f324b048b3434">'), 'html') ?>

    <p>Подробнее про <a href="/ru/manual/static#templates">темплейты статик тегов </a> ниже.</p>

  </section>

  <section>
    <header>
      <h1>
        <a name="time-hash" href="#time-hash">#</a>
        Хэш времени
      </h1>
    </header>
    <p>
      Дабы автоматизировать обновление загруженных файлов в кеше браузера, каждый файл, подключаемый через
      <a href="/ru/manual/tags#static-tags">статик теги</a>, будет иметь GET-параметр "time" в URL.
      Этот хэш основан на <a href="/ru/manual/config#random_stuff">секрете</a>, имени файла и его времени изменения.
      Когда файл изменяется, время изменяется, хэш изменяется и браузер получает другой URL для этого файла.
      Такм образом, браузер загрузит новую версию файла и вам не придётся нажимать Ctrl+F5, чтобы перезагрузить страницу
      без кэша браузера.
    </p>
    <p>В случае, если файл не будет обнаружен на харде, то будет подставлен обычный урл без хеша.</p>
  </section>

  <section>
    <header>
      <h1>
        <a name="servers-sharding" href="#servers-sharding">#</a>
        Шардинг серверов
      </h1>
    </header>
    <p>
      Современные браузеры могут скачивать по протоколу HTTP/1.1 контент страницы с одного сайта примерно в пять одновременных потоков.
      Если у вас на странице есть какие-то картинки, js скрипты и css файлы, браузер начнёт скачивать первые пять-шесть файлов,
      и не будет пытаться скачать другие файлы, пока эти не скачаются.
      Если у вас на странице таких файлов много, особенно маленьких, может уйти несколько секунд на то, чтобы браузер их все загрузил.
    </p>
    <p>
      Есть две основные стратегии ускорения загрузки страницы. Первая это склеить все картинки в одну большую,
      чтобы разом скачать их все в одном потоке, и использовать смещение background в стилях элементов, чтобы показывать
      соответствующие изображения на этих элементах. Ну или все css файлы в один слепить. На сегодня это лучшее решение в таких
      ситуациях.
    </p>
    <p>
      Вторая &mdash; использовать HTTP/2. Это отличная штука. Через одно подключение браузер может запросить у сервера
      сразу несколько, а то и все файлы разом.
    </p>
    <p>
      Если по каким-то прчинам вы не можете этого сделать, вам придётся увеличить количество одновременных потоков
      загрузки. Достичь этого можно распределив статик контент по нескольким серверам. Таким образом браузер сможет
      скачивать в пять потоков с каждого сервера.
    </p>
    <p>
      PinPIE реализует данный подход самым простым образом. Он выбирает сервер из списка случайным образом, предполагая,
      что все серверы содержат все файлы. На самом деле, не случайно, а на основе имени файла. Это нужно для того,
      чтобы один и тот же файл всегда был на одном и том же сервере. Таким образом кэш браузера сможет работать должным
      образом.
    </p>
    <p>
      Список статик серверов задаётся в конфиге в массиве <?= scx('$static_servers', 'php') ?> и доступен глобально через
      <?= scx('PinPIE::$conf->static_servers', 'php') ?>. По умолчанию это пустой массив, т.е. шардинг не осуществляется.
    </p>
    <p>
      Сервер выбирается в методе <?= scx('getServer($file)', 'php') ?> класса Staticon, где $file это путь к файлу внутри
      <?= scx('$tags["%"]["folder"]') ?>. На текущий момент нет способа переопределить этот метод в конфиге,
      но возможно однажды появится, дабы дать больше возможностей контроля над нагрузкой на серверы, балансировкой
      CDN и всяким таким.
    </p>
    <h3>Пример</h3>
    <p>Этот конфиг будет распределять запросы статик файлов на три сервера:</p>
    <?= pcx('$static_servers = [
  "s1." . $pinpie["site url"],
  "s2." . $pinpie["site url"],
  "s3." . $pinpie["site url"],
];') ?>
    <p>А этот тег</p>
    <?= pcx('[[%img=jpg.jpg]]', 'html') ?>
    <p>будет заменён на такой html-код:</p>
    <?= pcx(h('<img src="//s2.somesite.com/jpg.jpg?time=30c1c523bed6d902df19d9637831e41c" width="800" height="600">'), 'html') ?>

    <p>
      На самом деле, это может быть один единственный сервер, который обрабатывает все эти запросы.
      В любом случае, пользователь получит контент быстрее, чем если бы он загружался через один домен.
      Отдача статичных файлов это весьма простая задача для веб-сервера, а пользователь сделает одинаковое количество запросов
      что с шардингом, что без, так что переживать за нагрузку не стоит.
    </p>
  </section>

  <section>
    <header>
      <h1>
        <a name="custom-static-files-types" href="#custom-static-files-types">#</a>
        Кастомные типы
      </h1>
    </header>
    <p>Тип статик файла устанавливается в теге и может быть использован при преминификации и прекомпрессии.</p>
    <p>Синтаксис статик тега: <?= scx('[[%<b>type</b>=path]]', 'html') ?>.</p>
    <p>
      Сейчас существует три статик типа: js, css и img. По умолчанию js и css допускают сжатие и минификацию.
      Тип img не допукает ни того, ни другого, но поддерживает получение размеров изображения. Типы, которые можно минифицировать или сжимать содержатся в массивах
      <?= scx('$tags["%"]["minify types"]', 'php') ?> и <?= scx('$tags["%"]["gzip types"]', 'php') ?>
      соответственно. Вы можете использовать любой свой тип чтобы, например, задать различные настройки минификации.
    </p>
    <p>
      А вот сжатие gzip имеет только одну настройку &mdash; уровень сжатия
      <?= scx('$tags["%"]["gzip level"]', 'php') ?>. По умолчанию это пять.
    </p>
  </section>

  <section>
    <header>
      <h1>
        <a name="compression" href="#compression">#</a>
        Сжатие
      </h1>
    </header>
    <p>
      Вы можете настроить свой веб-сервер так, чтобы он отдавал
      <a href="https://www.google.ru/search?q=pre-compressed+static" target="_blank">заранее сжатые файлы</a>
      вместо оригинальных, или вместо того, чтобы сжимать их каждый раз заново на лету.
      Вы можете установить уровень сжатия в <?= scx('$tags["%"]["gzip level"]', 'php') ?>.
    </p>
    <p>Прекомпрессия применяется к тем типам файлов, которые перечислены в массиве</p>
    <?= pcx('$tags["%"]["gzip types"]', 'php') ?>
    <p>который по умолчанию такой:</p>
    <?= pcx("['js', 'css']") ?>
    <p>
      Если тип есть в массиве, тогда будет создан файл "имяфайла.gz". Если веб-сервер правильно настроен, то он станет использовать
      эти предварительно сжатые файлы. К сожалению, не гарантируется, что будет использована самая новая версия файла.
      Если оригинальный файл изменился, но не был пережат, скорее всего веб-сервер продолжит отдавать старый сжатый вариант.
      Чтобы этого избежать, PinPIE сам проверяет, не устарел ли сжатый файл, и пережимает новый в случае необходимости.
      Проверка времени изменения файла крайне быстрая операция, т.к. кэшируется самой ОС. Вам не стоит беспокоиться из-за производительности,
      и браузер всегда будет получать новейшую версию.
    </p>
  </section>

  <section>
    <header>
      <h1>
        <a name="minification" href="#minification">#</a>
        Минификация
      </h1>
    </header>
    <p>
      Грубо говоря, минификация это процесс уменьшения размера файла через отрбрасывание всех комментариев, лишних пробелов,
      символов новой строки, уменьшения имён функций, названий переменных и т.п.
      PinPIE может проверить, существует ли минифицированная версия запрошенного файла в папке, и поменять путь статик тега
      на путь к соответствующему файлу. Если минифицированная версия старше, чем оригинал, а тип тега в массиве
    </p>
    <?= pcx('$tags["%"]["minify types"]', 'php') ?>
    <p>тогда PinPIE запустит минифаер. По умолчанию список типов такой:</p>
    <?= pcx("['js', 'css']") ?>
    <p>Если тип тега есть в этом массиве, тогда PinPIE попробует вызвать функцию, содержащуюся в:</p>
    <?= pcx('$tags["%"]["minify function"]', 'php') ?>
    <p>
      Эту функцию вы должны написать сами. В этой функции вы должны вызвать свой любимый минификатор или же запланировать эту операцию.
      Вызов минификатора <b>может быть асинхронным</b>. В любом случае, будет использована новейшая версия файла.
    </p>
    <p>
      Чтобы избежать шквала одновременных попыток пережать новый или изменившийся файл при первых обращениях к нему, предусмотрены
      защитные механизмы. PinPIE не требует завершения минификации при запросе. После запуска функции минификации, управление можно
      вернуть в PHP, запустив консольный процесс отдельно. В таком случае PinPIE сразу после возврата из функции проверит файлы
      и подставит путь к тому, что новее. Чтобы гарантировать что для одного файла выполняется одна минификация одновременно,
      PinPIE пытается заблокировать файл на запись на время вызова функции минификатора,
      и на линуксе это работает точно, а на Windows &ndash; не уверен. В любом случае, если критично гарантировать лишь единократную
      минификацию, стоит с помощью кастомной функции минификации лишь вносить путь в некий список запланированных минификаций,
      и по крону минифицировать.
    </p>
    <p>Вы можете задать функцию минификации в конфиге сайта:</p>
    <?= pcx('/* вот так */
$tags["%"]["minify function"] = "runMyMinifier";
/* или так */
$tags["%"]["minify function"] = function(){/.../};') ?>
    <h2>Пример</h2>
    <p>
      Этот пример обрабатывает тег <?= scx('[[%css=/main.css]]') ?> и вызывает для минификации
      <a href="http://yui.github.io/yuicompressor/" target="_blank">YUI Compressor</a> &mdash; внешний исполняемый java файл.
    </p>
    <?= pcx('function autominify($filepath, $minfilepath, $type) {
  exec("java -jar /var/www/yuic.jar \"$filepath\" -o \"$minfilepath\" --type $type", $out, $err);
  return true;
}', 'php') ?>
    <p>Где:</p>
    <ul>
      <li>
        <?= scx('$filepath') ?> путь к файлу из тега.
        Его значение <?= scx('$tags["%"]["folder"] . "/main.css"') ?>.
      </li>
      <li>
        <?= scx('$minfilepath') ?> путь к минифицированной версии, которую нужно проверить.
        Значение: <?= scx('$tags["%"]["folder"] . "/main.min.css"') ?>
      </li>
      <li>
        <?= scx('$type') ?> в данном случае это "css". Тип <b>не</b> берётся из расширения файла.
        Он берётся из %<b>css</b> типа тега.
      </li>
      <li>
        <?= scx('$tags["%"]["minify types"]') ?> это массив с дефолтным значением <?= scx('["js", "css"]') ?>.
        Вы можете поменять его в конфиге.
      </li>
    </ul>
    <p>
      Помните, что вы можете запускать минификатор в бэкграунде, или просто запланировать эту операцию.
      Всё равно будет выбран самый новый файл.
    </p>
  </section>

  <section>
    <header>
      <h1>
        <a name="dimensions" href="#dimensions">#</a>
        Размеры
      </h1>
    </header>
    <p>PinPIE позволяет получить размеры картинки для некоторых типов статик тегов. Эти типы перечислены в массиве</p>
    <?= pcx('$tags["%"]["dimensions types"]', 'php') ?>
    <p>который по умолчанию:</p>
    <?= pcx('["img"]', 'php') ?>
    <p>
      Размеры выковыриваются благодаря классу FastImage (автор <a href="http://tommoor.com" target="_blank" title="Blog">Tom Moor</a>).
      Я запихал его в \PinPIE неймспейс чтобы не было конфликтов.
    </p>
    <p>
      Благодаря этому по умолчанию все картинки будут иметь свои размеры в html-тегах. Это позволяет браузеру заранее знать
      размеры картинок ещё до их загрузки, и снижает
      <a href="https://developers.google.com/speed/articles/reflow" title="Я не знаю подходящего перевода">reflow</a>
      и дёрганье при загрузке страницы.
    </p>
    <h3>Пример</h3>
    <p>Вот простой статик тег</p>
    <?= pcx('[[%img=jpg.jpg]]', 'html') ?>
    <p>Он заменяется следующим html-кодом:</p>
    <?= pcx(h('<img src="//s2.somesite.com/jpg.jpg?time=30c1c523bed6d902df19d9637831e41c" width="800" height="600">'), 'html') ?>
    <p>Как вы заметили, в этом теге присутствуют ширина и высота.</p>
  </section>

  <section>
    <header>
      <h1>
        <a name="i-don't-want-this" href="#i-don't-want-this">#</a>
        Мне это не нужно
      </h1>
    </header>
    <p>Всякий раз когда PinPIE находит статик тег, он проверяет его тип на наличие в следующих массивах:</p>
    <ul>
      <li><?= scx('$tags["%"]["minify types"]', 'php') ?></li>
      <li><?= scx('$tags["%"]["gzip types"]', 'php') ?></li>
      <li><?= scx('$tags["%"]["dimensions types"]', 'php') ?></li>
    </ul>
    <p>
      Если в этих массивах его нет &mdash; PinPIE не станет выполнять соответствующие действия.
    </p>
    <?= pcx('$tags["%"]["minify types"] = [];     // отключает минификацию
$tags["%"]["gzip types"] = [];       // отключает сжатие gzip
$tags["%"]["dimensions types"] = []; // отключает сбор картинковых размеров', 'php') ?>

    <p>
      Если вы хотите использовать эти механизмы с некоторыми изображениями, но не со всеми &mdash; вы можете использовать темплейты.
    </p>

  </section>

  <section>
    <header>
      <h1>
        <a name="templates" href="#templates">#</a>
        Темплейты
      </h1>
    </header>
    <p>
      В статик тегах типа <?= scx('[[%static=file]<b>template</b>]', 'html') ?> в темплейте доступны дополнительные плейсхолдеры.
      Вот полный список плейсхолдеров, доступных в темплейте статик тега:
    </p>
    <ul>
      <li><?= scx('[[*file path]]', 'html') ?> &mdash; путь к файлу на сервере</li>
      <li><?= scx('[[*url]]', 'html') ?> &mdash; url файла вместе с хостом</li>
      <li><?= scx('[[*time]]', 'html') ?> &mdash; integer unix modification time файла</li>
      <li><?= scx('[[*time hash]]', 'html') ?> &mdash; хэш, предотвращающий кэширование поменявшихся файлов</li>
      <li><?= scx('[[*width]]', 'html') ?> &mdash; ширина картинки, если возможно</li>
      <li><?= scx('[[*height]]', 'html') ?> &mdash; высота картинки, если возможно</li>
      <li><?= scx('[[*content]]', 'html') ?> &mdash; тот самый контент, который обычно требуется</li>
    </ul>

    <p>Давайте взглянем на примеры.</p>
    <h3>Пример 1</h3>
    <p>Если вы поставите восклицательный знак, то получите только путь:</p>
    <?= pcx('[[%img=jpg.jpg]wrap]
[[<b>!</b>%img=jpg.jpg]wrap]', 'html') ?>
    <p>Темплейт wrap.php с кодом:</p>
    <?= pcx(h('<div class="wrapper">[[*content]]</div>')) ?>
    <p>даст вам такой html:</p>
    <?= pcx(h('<div class="wrapper"><img src="//s2.somesite.com/jpg.jpg?time=30c1c523bed6d902df19d9637831e41c" width="800" height="600"></div>
<div class="wrapper">//s2.somesite.com/jpg.jpg?time=30c1c523bed6d902df19d9637831e41c</div>', 'html')) ?>
    <h3>Пример 2</h3>
    <p>Чтобы использовать ширину и высоту в вашем темплейте, просто разместите там подходящие плейсхолдеры:</p>
    <?= pcx(h('<div
  class="unusual div"
  style="
    background-image: url(\'[[*url]]?time=[[*time hash]]\');
    width: [[*width]]px;
    height: [[*height]]px;
  ">
</div>')) ?>
    <p>При использовании этого темплейта на картинковый статик тег</p>
    <?= pcx('[[%img=jpg.jpg]unusual]', 'html') ?>
    <p>вы получите следующий html-код:</p>
    <?= pcx(h('<div
  class="unusual div"
  style="
    background-image: url(\'//s2.somesite.com/jpg.jpg?time=30c1c523bed6d902df19d9637831e41c\');
    width: 430px;
    height: 604px;
  ">
</div>'), 'html') ?>
    <p>Помните: чтобы получить только путь, можете просто поставить восклицательный знак.</p>

  </section>

</article>
